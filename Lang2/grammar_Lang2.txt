(* Extended Backus-Naur Form (EBNF) for Morley *)

(* Toplevel *)

program ::=
  type_decl*
  parameter_decl
  storage_decl
  operation_decl
  function_decl*
  block
  EOF

parameter_decl ::= "parameter" Ident

storage_decl ::= "storage" type_expr

operation_decl ::= "operations" Ident

(* Type declarations *)

type_decl ::= "type" Ident "is" type_def

type_def ::=
  type_expr
| variants
| record_decl

type_expr ::=
  closed_type_expr
| open_type_expr

closed_type_expr ::=
  Ident
| const_type_constr
| "(" type_expr ")"

comparable_type ::=
  "int"
| "nat"
| "string"
| "bytes"
| "mutez"
| "bool"
| "key_hash"
| "timestamp"

const_type_constr ::=
  comparable_type
| "key"
| "unit"
| "signature"
| "operation"
| "address"

open_type_expr ::=
  "list"    domain
| "option"  domain
| "ref"     domain
| "set"     ordered_domain
| "map"     ordered_domain range
| "big_map" ordered_domain range
| {type_expr "*" ...}+

domain ::= closed_type_expr
range  ::= closed_type_expr

ordered_domain ::=
  comparable_type
| Ident

variants ::= {variant "|" ...}+
variant  ::= Constr "of" type_expr

record_decl ::= "{" {field_decl ";" ...}+ "}"
field_decl  ::= Ident ":" type_expr

(* Function declarations *)

function_decl ::=
  "function" Ident parameters ":" type_expr "=" block "with" Ident

parameters ::= "(" {param_decl ";" ...}* ")"

param_decl ::= ("var" | "const") Ident ":" type_expr

block ::=
  "begin"
    value_decls
    instructions
  "end"

value_decls ::= {value_decl ";" ...}*

value_decl ::=
  var_decl
| function_decl

var_decl ::= "var" Ident ":" type_expr ":=" expr

instructions ::= {instruction ";" ...}*

instruction ::=
  single_instr
| block

single_instr ::=
  conditional
| match
| asgnmnt
| loop

conditional ::= "if" expr "then" instruction "else" instruction

match ::= "match" expr "with" {case "|" ...}+ "end"

case ::= pattern "->" instruction

asgnmnt ::= Ident ":=" expr

loop ::=
  while
| for

while ::= "while" expr block

for ::=
  "for" asgnmnt ["down"] "to" expr ["step" expr] block
| "for" Ident ["->" Ident] "in" expr block

(* Expressions *)

expr ::=
  cons_expr "^" expr
| cons_expr

cons_expr ::=
  disj_expr "::" cons_expr
| disj_expr

disj_expr ::=
  disj_expr "||" conj_expr
| conj_expr

conj_expr ::=
  conj_expr "&&" comp_expr
| comp_expr

comp_expr ::=
  comp_expr "<"   add_expr
| comp_expr "<="  add_expr
| comp_expr ">"   add_expr
| comp_expr ">="  add_expr
| comp_expr "="   add_expr
| comp_expr "=/=" add_expr
| add_expr

add_expr ::=
  add_expr "+" mult_expr
| add_expr "-" mult_expr
| mult_expr

mult_expr ::=
  mult_expr "*"   unary_expr
| mult_expr "div" unary_expr
| mult_expr "mod" unary_expr
| unary_expr

unary_expr ::=
  "-" core_expr
| "not" core_expr
| core_expr

core_expr ::=
  Int
| Ident
| String
| "false"
| "true"
| tuple
| "[" {expr "," ...}+ "]"
| "{" {expr "," ...}+ "}"
| "(" "[" "]" ":" type_expr ")"
| "(" "None"  ":" type_expr ")"
| Ident tuple
| "nat" "(" expr ")"
| "(" expr ")"
| Ident "." "[" expr "]"

tuple ::= "(" {expr "," ...}* ")"

(* Patterns *)

pattern ::=
  head "<:" cons
| core_pattern

head ::=
  "(" cons ")"
| core_pattern

cons ::= {head "<:" ...}+

core_pattern ::=
  Ident
| "_"
| Int
| String
| "false"
| "true"
| "[" {cons "," ...}* "]"
| "(" {cons "," ...}* ")"
