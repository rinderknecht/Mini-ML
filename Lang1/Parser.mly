%{
(* START HEADER *)

open AST

(* END HEADER *)
%}

(* Entry points *)

%start program
%type <AST.t> program

%%

(* RULES

   This parser leverages Menhir-specific features, in particular
   parametric rules, rule inlining and primitives to get the source
   locations of tokens from the lexer engine generated by ocamllex.

     The Abstract Syntax Tree (AST) has been designed to be isomorphic
   to the grammar, that is, each grammatical rule (usually)
   corresponds to a node in the AST, except if it is inline. This
   enables simpler semantic actions, as we mostly have to pass the
   synthesised attributes in the productions to a data constructor of
   the AST.

     Auxiliary rules for handling source regions

     We define below two rules, [reg] and [oreg]. The former parses
   its argument and returns its synthesised value together with its
   region in the source code (that is, start and end positions --- see
   module [Region]). The latter discards the value and only returns
   the region: this is mostly useful for parsing keywords, because
   those can be easily deduced from the AST node and only their source
   region has to be recorded there.
*)

%inline reg(X):
  X { Region.make ~start:$symbolstartpos ~stop:$endpos, $1 }

%inline oreg(X):
  X { Region.make ~start:$symbolstartpos ~stop:$endpos }

(* Keywords in common with OCaml *)

%inline kwd_and:   oreg(And)     { $1 }
%inline kwd_else:  oreg(Else)    { $1 }
%inline kwd_false: oreg(False)   { $1 }
%inline kwd_fun:   oreg(Fun)     { $1 }
%inline kwd_if:    oreg(If)      { $1 }
%inline kwd_in:    oreg(In)      { $1 }
%inline kwd_let:   oreg(Let)     { $1 }
%inline kwd_mod:   oreg(Mod)     { $1 }
%inline kwd_not:   oreg(Not)     { $1 }
%inline kwd_rec:   oreg(Rec)     { $1 }
%inline kwd_then:  oreg(Then)    { $1 }
%inline kwd_true:  oreg(True)    { $1 }

(* Symbols *)

%inline arrow:    oreg(ARROW)    { $1 }
%inline cons:     oreg(CONS)     { $1 }
%inline cat:      oreg(CAT)      { $1 }
%inline minus:    oreg(MINUS)    { $1 }
%inline plus:     oreg(PLUS)     { $1 }
%inline div:      oreg(DIV)      { $1 }
%inline mult:     oreg(MULT)     { $1 }
%inline lpar:     oreg(LPAR)     { $1 }
%inline rpar:     oreg(RPAR)     { $1 }
%inline lbrack:   oreg(LBRACK)   { $1 }
%inline rbrack:   oreg(RBRACK)   { $1 }
%inline comma:    oreg(COMMA)    { $1 }
%inline semi:     oreg(SEMI)     { $1 }
%inline wild:     oreg(WILD)     { $1 }
%inline eq:       oreg(EQ)       { $1 }
%inline ne:       oreg(NE)       { $1 }
%inline lt:       oreg(LT)       { $1 }
%inline gt:       oreg(GT)       { $1 }
%inline le:       oreg(LE)       { $1 }
%inline ge:       oreg(GE)       { $1 }
%inline bool_or:  oreg(BOOL_OR)  { $1 }
%inline bool_and: oreg(BOOL_AND) { $1 }

(* Literals *)

%inline ident:    reg(Ident)     { $1 }
%inline string:   reg(Str)       { $1 }

(* Virtual tokens *)

%inline eof:      oreg(EOF)      { $1 }

(* Compounds *)

par(X): reg(lpar X rpar {$1,$2,$3}) { $1 }

bracket(X): lbrack X rbrack { $1,$2,$3 }

(* Sequences

   Series of instances of the same syntactical category have often to
   be parsed, like lists of expressions, patterns etc. The simplest of
   all is the possibly empty sequence (series), parsed below by
   [seq]. The non-empty sequence is parsed by [nseq]. Note that the
   latter returns a pair made of the first parsed item (the parameter
   [X]) and the rest of the sequence (possibly empty). This way, the
   OCaml typechecker can keep track of this information along the
   static control-flow graph. The rule [sepseq] parses possibly empty
   sequences of items separated by some token (e.g., a comma), and
   rule [nsepseq] is for non-empty such sequences. See module [Utils]
   for the types corresponding to the semantic actions of those
   rules.  *)

(* Non-empty sequence of items *)

nseq(X):
  X seq(X) { $1,$2 }

(* Possibly empty sequence of items *)

seq(X):
  (**)     {     [] }
| X seq(X) { $1::$2 }

(* Non-empty separated sequence of items *)

nsepseq(X,Sep):
  X                    {                        $1, [] }
| X Sep nsepseq(X,Sep) { let h,t = $3 in $1, ($2,h)::t }

(* Possibly empy separated sequence of items *)

sepseq(X,Sep):
  (**)           {    None }
| nsepseq(X,Sep) { Some $1 }

(* Non-empty comma-separated values *)

csv(X):
  reg(X comma nsepseq(X,comma) { let hd,tl = $3 in $1, ($2,hd)::tl }) { $1 }

(* Possibly empty semicolon-separated values between brackets *)

list__(X):
  reg(bracket(sepseq(X,semi))) { $1 }

(* Main *)

program:
  seq(statement) eof                                                    { $1,$2 }

statement:
  reg(kwd_let         let_bindings     {$1,$2})                     {    Let $1 }
| reg(kwd_let kwd_rec let_rec_bindings {$1,$2,$3})                  { LetRec $1 }

(* Recursive definitions *)

let_rec_bindings:
  nsepseq(let_rec_binding, kwd_and)                                        { $1 }

let_rec_binding:
  ident nseq(pattern) eq expr                 { $1, Region.ghost, norm $2 $3 $4 }
| ident               eq fun_expr             { $1,           $2,            $3 }

(* Non-recursive definitions *)

let_bindings:
  nsepseq(let_binding, kwd_and)                                            { $1 }

let_binding:
  ident nseq(pattern) eq expr                  { let expr = Fun (norm $2 $3 $4)
                                                 in Pvar $1, Region.ghost, expr }
| ident               eq expr                  {                Pvar $1, $2, $3 }
| non_rec_lhs         eq expr                  {                     $1, $2, $3 }

(* Patterns *)

non_rec_lhs:
  common_pattern                                                    {        $1 }
| reg(pattern cons cons_pat {$1,$2,$3})                             {  Pcons $1 }
| csv(pattern)                                                      { Ptuple $1 }

common_pattern:
  wild                                                              {  Pwild $1 }
| unit                                                              {  Punit $1 }
| list__(cons_pat)                                                  {  Plist $1 }
| par(ptuple)                                                       {   Ppar $1 }

ptuple:
  csv(cons_pat)                                                     { Ptuple $1 }

unit:
  reg(lpar rpar {$1,$2})                                                   { $1 }

cons_pat:
  reg(pattern cons cons_pat {$1,$2,$3})                              { Pcons $1 }
| pattern                                                            {       $1 }

pattern:
  common_pattern                                                      {      $1 }
| ident                                                               { Pvar $1 }
| par(cons_pat)                                                       { Ppar $1 }

(* Expressions *)

expr:
  reg(let_expr)                                                    { LetExpr $1 }
| cat_expr                                                         { CatExpr $1 }
| csv(cat_expr)                                                    {   Tuple $1 }
| reg(conditional)                                                 {      If $1 }
| fun_expr                                                         {     Fun $1 }

let_expr:
  kwd_let         let_bindings     kwd_in expr      {    LetIn ($1,$2,$3,$4)    }
| kwd_let kwd_rec let_rec_bindings kwd_in expr      { LetRecIn ($1,$2,$3,$4,$5) }

conditional:
  kwd_if expr kwd_then expr kwd_else expr                   { $1,$2,$3,$4,$5,$6 }

fun_expr:
  reg(kwd_fun nseq(pattern) arrow expr {$1,$2,$3,$4}) {
    let reg, (kwd_fun, patterns, arrow, expr) = $1
    in norm ~reg:(reg, kwd_fun) patterns arrow expr
  }

cat_expr:
  reg(cons_expr cat cat_expr {$1,$2,$3})                         {       Cat $1 }
| cons_expr                                                      {  ConsExpr $1 }

cons_expr:
  reg(disj_expr cons cons_expr {$1,$2,$3})                       {      Cons $1 }
| disj_expr                                                      {  DisjExpr $1 }

disj_expr:
  reg(disj_expr bool_or conj_expr {$1,$2,$3})                    {        Or $1 }
| conj_expr                                                      {  ConjExpr $1 }

conj_expr:
  reg(conj_expr bool_and comp_expr {$1,$2,$3})                   {       And $1 }
| comp_expr                                                      {  CompExpr $1 }

comp_expr:
  reg(comp_expr lt add_expr {$1,$2,$3})                          {        Lt $1 }
| reg(comp_expr le add_expr {$1,$2,$3})                          {       LEq $1 }
| reg(comp_expr gt add_expr {$1,$2,$3})                          {        Gt $1 }
| reg(comp_expr ge add_expr {$1,$2,$3})                          {       GEq $1 }
| reg(comp_expr eq add_expr {$1,$2,$3})                          {        Eq $1 }
| reg(comp_expr ne add_expr {$1,$2,$3})                          {       NEq $1 }
| add_expr                                                       {   AddExpr $1 }

add_expr:
  reg(add_expr plus   mult_expr {$1,$2,$3})                      {       Add $1 }
| reg(add_expr minus  mult_expr {$1,$2,$3})                      {       Sub $1 }
| mult_expr                                                      {  MultExpr $1 }

mult_expr:
  reg(mult_expr mult    unary_expr {$1,$2,$3})                   {      Mult $1 }
| reg(mult_expr div     unary_expr {$1,$2,$3})                   {       Div $1 }
| reg(mult_expr kwd_mod unary_expr {$1,$2,$3})                   {       Mod $1 }
| unary_expr                                                     { UnaryExpr $1 }

unary_expr:
  reg(minus   core_expr {$1,$2})                                 {       Neg $1 }
| reg(kwd_not core_expr {$1,$2})                                 {       Not $1 }
| primary_expr                                                   {   Primary $1 }

primary_expr:
  reg(primary_expr core_expr {$1,$2})                            {  CallExpr $1 }
| core_expr                                                      {  CoreExpr $1 }

core_expr:
  reg(Int)                                                       {       Int $1 }
| ident                                                          {       Var $1 }
| string                                                         {       Str $1 }
| unit                                                           {      Unit $1 }
| kwd_false                                                      {     False $1 }
| kwd_true                                                       {      True $1 }
| list__(expr)                                                   {      List $1 }
| par(expr)                                                      {       Par $1 }
